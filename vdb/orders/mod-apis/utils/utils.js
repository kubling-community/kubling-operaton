/***************************************************************************
 * Kubling Connector Utility Functions
 * -----------------------------------
 * A collection of small helpers used across Kubling connector modules.
 *
 * They are intentionally minimal and synchronous to match the Kubling
 * connector execution environment.
 ***************************************************************************/

/* -------------------------------------------------------------------------
 * Basic null / undefined checks
 * ---------------------------------------------------------------------- */
export function isNull(obj) {
    return (obj === null);
}

export function isUndefinedOrNull(obj) {
    return (obj === null || obj === undefined);
}

export function isNotUndefinedOrNull(obj) {
    return !isUndefinedOrNull(obj);
}

/* -------------------------------------------------------------------------
 * Type guards for Array and Map
 * ---------------------------------------------------------------------- */
export function isArray(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
}

export function isMap(value) {
    return Object.prototype.toString.call(value) === '[object Map]';
}

/* Array / Map emptiness helpers */
export function isArrayEmpty(value) {
    if (!isUndefinedOrNull(value) && isArray(value))
        return value.length === 0;
    return true;
}

export function isMapEmpty(value) {
    if (!isNull(value) && isMap(value))
        return value.size === 0;
    return true;
}

/* -------------------------------------------------------------------------
 * Structural helpers
 * ---------------------------------------------------------------------- */
export function cloneArray(a) {
    return [...a];
}

/* -------------------------------------------------------------------------
 * HTTP client helpers (for auto-generated clients)
 * ---------------------------------------------------------------------- */

/**
 * Extracts and deserializes the content from a response, using the
 * autogenerated API client's deserializer for the given type.
 */
export function httpCliResponseContent(resp, type, apiClient) {
    return (!resp.content)
        ? {}
        : apiClient.deserialize(JSON.parse(resp.content), type);
}

/**
 * Many paginated APIs include `isLast` to signal the end of the stream.
 * If not present, the safe default is `true` (single-page APIs).
 */
export function responseIsLast(resp) {
    const ret = JSON.parse(resp.content);
    return (isNotUndefinedOrNull(ret.isLast)) ? ret.isLast : true;
}

/* -------------------------------------------------------------------------
 * Function-name matching helpers
 * Useful when Kubling injects a function group by name.
 * ---------------------------------------------------------------------- */
export function functionGroupMatches(f, name) {
    return (typeof f === 'function') && name.startsWith(f.name);
}

export function functionMatches(f, name) {
    return (typeof f === 'function') && (f.name === name);
}

/* -------------------------------------------------------------------------
 * HTTP error handling helpers for callback-style clients
 * ---------------------------------------------------------------------- */

/**
 * Determines whether the connector should return an empty result set
 * based on an error.
 *
 * Convention:
 *   - 404 → harmless empty result
 *   - anything else → throw
 */
export function shallReturnEmpty(err, code) {
    if (isNotUndefinedOrNull(err)) {
        if (code === 404) return true;
        throw new Error(`Code: ${code} - Message: ${err}`);
    }
    return false;
}

/**
 * callback(err, data, code) handler for listing APIs returning:
 *   { values: [...] }
 */
export function httpCallbackResultSet(err, data, code, enricher) {
    if (shallReturnEmpty(err, code)) return;
    if (isUndefinedOrNull(data) || isUndefinedOrNull(data.values)) return;

    for (let v of data.values) {
        if (enricher) v = enricher(v);
        resultSet.addRow(JSON.stringify(v));
    }
}

/**
 * Same as above, but for APIs that directly return arrays.
 */
export function httpCallbackArrayResultSet(err, data, code, enricher) {
    if (shallReturnEmpty(err, code)) return;
    if (isUndefinedOrNull(data)) return;

    for (let v of data) {
        if (enricher) v = enricher(v);
        resultSet.addRow(JSON.stringify(v));
    }
}

/**
 * Same pattern, but for APIs returning a single document.
 */
export function httpCallbackSingleResultSet(err, data, code, enricher) {
    if (shallReturnEmpty(err, code)) return;
    if (isUndefinedOrNull(data)) return;

    if (enricher) data = enricher(data);
    resultSet.addRow(JSON.stringify(data));
}

/**
 * Basic callback for INSERT/UPDATE/DELETE operations.
 * Any error (except 404) is fatal.
 */
export function baseOperationCallback(err, data, code) {
    if (isNotUndefinedOrNull(err))
        throw new Error(`Code ${code} Message: ${err}`);

    affectedRows.increment();
}

/* -------------------------------------------------------------------------
 * Query filter helpers
 * ---------------------------------------------------------------------- */

/**
 * Returns the list of filter objects for a specific field and operation.
 */
export function getFiltersOfField(tableFieldName, operation, qf) {
    return qf.filters.filter(
        (f) => f.field === tableFieldName && f.operation == operation
    );
}

/**
 * Same as above, but returns only the values.
 */
export function getFiltersOfFieldVal(tableFieldName, operation, qf) {
    return qf.filters
        .filter((f) => f.field === tableFieldName && f.operation == operation)
        .map((f) => f.value);
}

/**
 * Some APIs only allow one EQUAL filter per field.
 * If the query contains multiple values (X = 1 AND X = 2),
 * this helper skips pushdown entirely and leaves full filtering to Kubling.
 */
export function addUniqueFieldFilterEqualOrNothing(ops, tableFieldName, opsFieldName, qf) {

    const ff = getFiltersOfField(tableFieldName, "EQUAL", qf);
    if (isArrayEmpty(ff)) return ops;

    // More than one → let Kubling handle filtering
    if (ff.length > 1) return ops;

    // Single value → safe to pushdown
    ops[opsFieldName] = ff[0].value;

    return ops;
}

/**
 * Same pattern as above, but throws if the required field filter is missing.
 * Useful for APIs that force mandatory parameters.
 */
export function requiresFieldFilter(ops, tableFieldName, opsFieldName, qf, message) {

    const ff = qf.filters.filter(
        (f) => f.field === tableFieldName && f.operation == "EQUAL"
    );

    if (isArrayEmpty(ff)) throw new Error(message);

    if (ff.length > 1) return ops;

    ops[opsFieldName] = ff[0];
    return ops;
}

/* -------------------------------------------------------------------------
 * API iteration combinatorics
 * ---------------------------------------------------------------------- */

/**
 * Computes how many iterations would be required if an API needs
 * to issue a call per possible combination of filter values.
 *
 * Example:
 *   field A has 3 values
 *   field B has 4 values
 *   → requires 3 * 4 = 12 calls
 */
export function computeTotalIterations(...arrays) {
    if (arrays.length === 0) return 0;
    return arrays.reduce((total, arr) => total * arr.length, 1);
}

/**
 * Throws if the number of required API calls exceeds a safe limit.
 * Prevents accidentally issuing dozens or hundreds of upstream calls.
 */
export function checkTotalIterations(...arrays) {
    if (computeTotalIterations(arrays) > 5)
        throw Error("Too many API calls are needed to execute this query. Aborting.");
}
